 
<!DOCTYPE html>
<html lang="en">
<head class="include" file="../include/header.html">
<link rel="stylesheet" href="../include/bootstrap.min.css">
<link rel="stylesheet" href="../include/bootstrap-theme.min.css">
<link rel="stylesheet" href="../include/bootstrap-select.min.css">
<link rel="stylesheet" href="../include/style.css" type="text/css">
<link rel="stylesheet" href="../include/highlight.css" type="text/css">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta NAME="keywords" CONTENT="reproducible, research, platform, rrp, rr, reproducible research, reproducible research platform, matlab, code, mat2doc, science, knowledge"/>

<title>RR_IMAGE_SOURCE_SEPARATION_BIG_DATASET - Application of the bloc diagonal method on a big dataset</title>
</head>



<!-- body must stay hidden until all include parts are loaded -->
<body style="display:none;">
<!-- Wrap the content into responsive container -->
<div class="container">
<!-- Include main navigation -->
    <div class="masthead include" file="../include/mainnav.html"></div>
        <div class="row">
            <div class="col-md-2" id="codeswitch"><div id="menutitle"><a href="rr_image_source_separation_big_dataset.html">View the help</a></div>
</div>
            <div class="btn btn-large btn-success span22-doc">
                <a style="color: #FFFFFF" href="../archive/#PACKAGE#.zip">Download <font color="red">r<sup>2</sup>&pi;</font> archive for windows</a>
                <a style="color: #FFFFFF" href="../archive/#PACKAGE#.tgz"> or for unix </a> 
            </div>
        </div>
        <div class="row">
            <div class="col-md-2">
                <div class="include" file='contentsmenu.html'></div>
                <br/>
                <div id="seealso"><p></p></div>
                <br/>
            </div>
            <div class="col-md-10">
           
                    <h1 class="title">RR_IMAGE_SOURCE_SEPARATION_BIG_DATASET - Application of the bloc diagonal method on a big dataset</h1>
<h2>Program code:</h2>
<div class="highlight"><pre><span></span><span class="c">%RR_IMAGE_SOURCE_SEPARATION_BIG_DATASET Application of the bloc diagonal method on a big dataset</span>
<span class="c">%                           </span>
<span class="c">%   Reproducible research addendum for compressive source separation</span>
<span class="c">%   ----------------------------------------------------------------</span>
<span class="c">%   </span>
<span class="c">%   THEORY AND METHODS FOR HYPERSPECTRAL IMAGING</span>
<span class="c">%</span>
<span class="c">%   Paper: Mohammad Golbabaee, Simon Arberet, and Pierre Vandergheynst</span>
<span class="c">%   </span>
<span class="c">%   Demonstration matlab file: Perraudin Nathanael, Mohammad Golbabaee</span>
<span class="c">%</span>
<span class="c">%   EPFL -- August 2012</span>
<span class="c">%   </span>
<span class="c">%   Dependencies</span>
<span class="c">%   ------------</span>
<span class="c">%</span>
<span class="c">%   In order to use this matlab file you need the UNLocXbox toolbox. You</span>
<span class="c">%   can download it on https://lts2research.epfl.ch/unlocbox/</span>
<span class="c">%</span>
<span class="c">%   The problem</span>
<span class="c">%   -----------</span>
<span class="c">%  </span>
<span class="c">%   We would like to solve this problem: </span>
<span class="c">%</span>
<span class="c">%        argmin_S   Sum_j ||S_{.,j}||_TV </span>
<span class="c">%</span>
<span class="c">%        such that  || Phi ( S * H^t ) - Y ||_F &lt; epsilon   Projection on a B2-Ball</span>
<span class="c">%                                                       </span>
<span class="c">%             and   (S)_{i,j} &gt; 0         for all i,j     (positivity constraint)</span>
<span class="c">%</span>
<span class="c">%             and   Sum_j   S_{i,j}  = 1  for all i</span>
<span class="c">%</span>
<span class="c">%   with </span>
<span class="c">%         - S :  Sources</span>
<span class="c">%         - Y =  Phi(I_m) + Z: the measurement (forward model)</span>
<span class="c">%         - Z :  noise</span>
<span class="c">%         - I_m:  Original 3D image  (64 x 64 x 64) in &#39;Data.mat&#39;</span>
<span class="c">%         - H :  Mixing matrix</span>
<span class="c">%</span>
<span class="c">%   Uniform sampling</span>
<span class="c">%   ----------------</span>
<span class="c">%</span>
<span class="c">%   For UNIFORM sampling (Block_diag), a decorrelation step can be applied</span>
<span class="c">%   by projecting the measurements onto pinv(H), and solve a easier</span>
<span class="c">%   problem:</span>
<span class="c">%   </span>
<span class="c">%        argmin_S   Sum_j ||Sp_{.,j}||_TV </span>
<span class="c">%       </span>
<span class="c">%        such that  || Phi *  Sp  - Yp ||_F &lt; epsilon  Projection on a B2-Ball</span>
<span class="c">%                                                   </span>
<span class="c">%             and   (Sp)_{i,j} &gt; 0        for all i,j  (positivity constraint)</span>
<span class="c">%</span>
<span class="c">%             and   Sum_j   Sp_{i,j}  = 1 for all i</span>
<span class="c">%   </span>
<span class="c">%             with  Yp =  Y * (P_inv(H))&#39; </span>
<span class="c">%   </span>
<span class="c">%   with </span>
<span class="c">%         - Y =  Phi I_m + Z: the measurement (forward model)</span>
<span class="c">%</span>
<span class="c">%   This step accelerates the computation and increase accuracy of source recovery. </span>
<span class="c">%   However, the use of the block diagonale (Block_diag) sampling is required!</span>
<span class="c">%</span>
<span class="c">%   Results</span>
<span class="c">%   -------</span>
<span class="c">%</span>
<span class="c">%   Figure 1: Sprectral signature of the different sources</span>
<span class="c">%</span>
<span class="c">%       </span>
<span class="c">%</span>
<span class="c">%   Figure 2: Orignial sources</span>
<span class="c">%</span>
<span class="c">%       </span>
<span class="c">%</span>
<span class="c">%   Figure 3: Block_diag operator with TV regularization (Uncorrelated measurements)</span>
<span class="c">%</span>
<span class="c">%       </span>
<span class="c">%</span>
<span class="c">%   Figure 4: Block_diag operator with Wavelets regularization (Uncorrelated measurements)</span>
<span class="c">%</span>
<span class="c">%       </span>
<span class="c">%</span>
<span class="c">%   References:</span>
<span class="c">%     M. Golbabaee, S. Arberet, P. Vandergheynst, et al. Multichannel</span>
<span class="c">%     compressed sensing via source separation for hyperspectral images. In</span>
<span class="c">%     Eusipco 2010, 2010.</span>
<span class="c">%     </span>
<span class="c">%</span>
<span class="c">%</span>
<span class="c">%   Url: https://epfl-lts2.github.io/rrp-html/image_source_separation/rr_image_source_separation_big_dataset.html</span>

<span class="c">% Copyright (C) 2012-2013 Nathanael Perraudin.</span>
<span class="c">% This file is part of RRP version 0.2</span>
<span class="c">%</span>
<span class="c">% This program is free software: you can redistribute it and/or modify</span>
<span class="c">% it under the terms of the GNU General Public License as published by</span>
<span class="c">% the Free Software Foundation, either version 3 of the License, or</span>
<span class="c">% (at your option) any later version.</span>
<span class="c">%</span>
<span class="c">% This program is distributed in the hope that it will be useful,</span>
<span class="c">% but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c">% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c">% GNU General Public License for more details.</span>
<span class="c">%</span>
<span class="c">% You should have received a copy of the GNU General Public License</span>
<span class="c">% along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>



<span class="c">%% Initialization</span>

    <span class="n">clear</span><span class="p">;</span>
    <span class="n">close</span> <span class="n">all</span><span class="p">;</span>

    <span class="c">% adding path</span>
<span class="c">%     addpath(genpath(&#39;./&#39;))</span>
    <span class="n">init_unlocbox</span><span class="p">()</span>
    <span class="k">global</span> <span class="n">GLOBAL_useGPU</span><span class="p">;</span>
    <span class="n">verbose</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="c">%% General parameter</span>
 
    <span class="n">sampling_ratios</span> <span class="p">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">16</span><span class="p">;</span>             <span class="c">% compression ratio   only 2^(-p) with  p =1,2,3,... (random convolution RC)</span>

    <span class="n">SNR</span> <span class="p">=</span> <span class="nb">inf</span><span class="p">;</span>                          <span class="c">% SNR (dB)-- inf =&gt; no noise</span>
    
    <span class="n">sampling_mecanism</span> <span class="p">=</span> <span class="s">&#39;Block_diag&#39;</span><span class="p">;</span>   
    
    <span class="n">decorr</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>                         <span class="c">% decorrelation method (ONLY for Block_diag sampling)</span>
    
    
    <span class="c">%reply = input(&#39;Would you like TV or Wavelet-L1 minimization? 1 = TV / 2 = Wavelet-L1 [1]: &#39;, &#39;s&#39;);</span>
    <span class="c">%if isempty(reply)</span>
    <span class="c">%    reply = &#39;1&#39;;</span>
    <span class="c">%end</span>
    
    <span class="c">%if strcmp(reply,&#39;1&#39;)</span>
    <span class="c">%   method = &#39;TV&#39;;                      % &#39;TV&#39; minimization </span>
    <span class="c">%elseif strcmp(reply,&#39;2&#39;)</span>
    <span class="c">%    method = &#39;Wavelet-L1&#39;;             % &#39;Wavelet-L1&#39; minimization</span>
    <span class="c">%else</span>
    <span class="c">%    error(&#39;Wrong input&#39;)</span>
    <span class="c">%end</span>
        
        

<span class="c">%% Loading data for the problem</span>

    <span class="n">load</span> <span class="s">&#39;Data_big.mat&#39;</span>                 <span class="c">% Synthetic Geneve images 64*64*64</span>
    
    <span class="n">Img</span> <span class="p">=</span> <span class="n">sources</span><span class="o">*</span><span class="n">H</span><span class="o">&#39;</span><span class="p">;</span>
    
    <span class="p">[</span><span class="n">N</span> <span class="p">,</span> <span class="n">J</span><span class="p">]</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">Img</span><span class="p">);</span>                <span class="c">% N dimention of the image, J number of image</span>
    
    <span class="n">n1</span><span class="p">=</span><span class="nb">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>                         <span class="c">% square image x and y dimension</span>
    <span class="n">n2</span><span class="p">=</span><span class="n">n1</span><span class="p">;</span>                             
    
    <span class="n">nb_meas</span> <span class="p">=</span> <span class="nb">floor</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">sampling_ratios</span><span class="p">);</span> <span class="c">% Number of measurements per image</span>

    <span class="n">I</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>                      <span class="c">% Number of expected sources</span>
    
      
    <span class="c">% display the sources and the mixing parameters</span>
    <span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c">%subplot(121)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="n">title</span><span class="p">(</span><span class="n">sprintf</span><span class="p">(</span><span class="s">&#39; Mixing Parameters \n (Spectral signatures) \n Sampling ratio: %g \n SNR: %g&#39;</span><span class="p">,</span><span class="n">sampling_ratios</span><span class="p">,</span> <span class="n">SNR</span><span class="p">));</span>
    <span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Spectral band&#39;</span><span class="p">)</span>
    <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Reflectance&#39;</span><span class="p">)</span>
    <span class="n">axis</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="nb">size</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">H</span><span class="p">)))</span><span class="o">*</span><span class="mf">1.1</span><span class="p">,</span><span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">H</span><span class="p">))</span><span class="o">*</span><span class="mf">1.1</span><span class="p">])</span>
    <span class="c">%subplot(222)</span>
    
        <span class="c">% plot the result in a nice shape</span>
        <span class="n">sources</span><span class="p">=</span><span class="n">sources</span><span class="p">(:);</span>
        <span class="n">sources1</span><span class="p">=</span><span class="n">sources</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">*</span><span class="n">I</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">sources2</span><span class="p">=</span><span class="n">sources</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">N</span><span class="o">*</span><span class="n">I</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">);</span>
        <span class="n">sources1</span><span class="p">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">sources1</span><span class="p">,</span><span class="n">n1</span><span class="p">,[]);</span>
        <span class="n">sources2</span><span class="p">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">sources2</span><span class="p">,</span><span class="n">n1</span><span class="p">,[]);</span>
    <span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">imagesc</span><span class="p">([</span><span class="n">sources1</span><span class="p">;</span><span class="n">sources2</span><span class="p">]);</span>
        <span class="n">set</span><span class="p">(</span><span class="n">gca</span><span class="p">,</span><span class="s">&#39;xtick&#39;</span><span class="p">,[])</span>

        <span class="n">colormap</span> <span class="n">hot</span><span class="p">;</span>
        <span class="c">% Plot separtation lines</span>
        <span class="n">hold</span> <span class="n">on</span><span class="p">;</span>
        <span class="n">N_lines</span><span class="p">=</span><span class="n">I</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N_lines</span><span class="p">;</span>
           <span class="n">plot</span><span class="p">(</span><span class="n">ii</span><span class="o">*</span><span class="n">n2</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="s">&#39;k&#39;</span><span class="p">,</span><span class="s">&#39;Linewidth&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="k">end</span>

        <span class="n">plot</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="n">n1</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">n2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;k&#39;</span><span class="p">,</span><span class="s">&#39;Linewidth&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        
    <span class="n">title</span><span class="p">(</span><span class="n">sprintf</span><span class="p">(</span><span class="s">&#39; Ground Truth \n (Orignial sources) S_1,S_2,..., S_I, I=%i &#39;</span><span class="p">,</span><span class="n">I</span><span class="p">))</span> 
    <span class="n">drawnow</span><span class="p">;</span>
    
    

<span class="c">%% Compressed sampling step</span>

    <span class="c">%Sampling operator identification.</span>
       <span class="n">opCS</span> <span class="p">=</span> <span class="n">opRC_measur_matrix</span><span class="p">(</span> <span class="n">N</span><span class="p">,</span> <span class="n">nb_meas</span><span class="p">);</span>   <span class="c">% 2D Image CS by Random Convolution RC(J. Romberg 2009).</span>
       <span class="n">opCS_multichannel</span> <span class="p">=</span> <span class="n">opBlock_diag_same</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">opCS</span> <span class="p">);</span>
          <span class="c">% t_gen = sigma_gen(N);</span>
          <span class="c">% s_gen = theta(N);</span>
          <span class="c">% opCS_multichannel = opBlock_Diag_RC_measur_matrix(N,J,nb_meas,s_gen, t_gen);</span>
        <span class="n">Phi</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">)</span> <span class="n">opCS_multichannel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">Phit</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">)</span> <span class="n">opCS_multichannel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">nu_phi</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="c">% Since opRC is a normalized tight frame.</span>
        <span class="n">tight_phi</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c">% Phi is a tight frame</span>
        
        <span class="k">if</span> <span class="n">decorr</span> <span class="o">==</span> <span class="mi">1</span> <span class="c">%    if decorrelation step applies we need to redefine</span>
                       <span class="c">%    the block diagonal operator Phi with a smaller</span>
                       <span class="c">%    dimension.</span>

            <span class="c">%opCS_multichannel1 = opBlock_Diag_RC_measur_matrix(N,I,nb_meas,s_gen, t_gen);</span>
            <span class="n">opCS_multichannel1</span> <span class="p">=</span> <span class="n">opBlock_diag_same</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">opCS</span> <span class="p">);</span>
            <span class="n">Phi1</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">)</span> <span class="n">opCS_multichannel1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">Phit1</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">)</span> <span class="n">opCS_multichannel1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">Phi1</span> <span class="p">=</span> <span class="n">Phi</span><span class="p">;</span>     <span class="c">% Here no difference between Phi1 and Phi. This</span>
                            <span class="c">% is done for compatibilty reason</span>
            <span class="n">Phit1</span> <span class="p">=</span> <span class="n">Phit</span><span class="p">;</span>
        <span class="k">end</span>






    <span class="c">% Measurements without noise</span>
    <span class="n">y</span> <span class="p">=</span> <span class="n">Phi</span><span class="p">(</span><span class="n">Img</span><span class="p">(:));</span> 


    <span class="c">% Adding noise to the mesaurement depending of the SNR</span>
    <span class="n">sigma</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="nb">sqrt</span><span class="p">(</span> <span class="mi">10</span>^<span class="p">(</span><span class="o">-</span><span class="n">SNR</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nb_meas</span><span class="o">*</span><span class="n">J</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">z</span> <span class="p">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="nb">randn</span><span class="p">(</span><span class="n">nb_meas</span><span class="o">*</span><span class="n">J</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>  <span class="c">% create the noise</span>


    <span class="n">y</span> <span class="p">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span>              <span class="c">% Additive white gaussian noise.</span>

    <span class="c">% If the measurement are decorrelated, we solve the problem in a</span>
    <span class="c">% subspace. So we replace the measurement y by P_inv(H) * y</span>
    <span class="k">if</span> <span class="n">decorr</span><span class="o">==</span><span class="mi">1</span>
        <span class="c">% compute P_inv(H) * y</span>
        <span class="n">y</span> <span class="p">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">[],</span> <span class="n">J</span><span class="p">);</span>
        <span class="n">y</span> <span class="p">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">H</span><span class="o">*</span><span class="n">inv</span><span class="p">(</span><span class="n">H</span><span class="o">&#39;*</span><span class="n">H</span><span class="p">);</span>
        <span class="n">y</span> <span class="p">=</span> <span class="n">y</span><span class="p">(:);</span>
    <span class="k">end</span>


<span class="c">%% Define the 3 different prox for the problem  </span>
    
    <span class="c">%****  Proj L2  *******************************************************</span>
    <span class="c">%</span>
    <span class="c">%   Projection on a B2-ball</span>
    <span class="c">%</span>
    <span class="c">%   || Phi (S * H) - y ||_2 &lt; epsilon </span>
    
    <span class="k">if</span> <span class="n">decorr</span><span class="o">==</span><span class="mi">1</span>
        <span class="c">% if measurement are decorrelated, we do not need put H in the</span>
        <span class="c">% projection, so we replace it by the eye matrix (compatibility</span>
        <span class="c">% reasons).</span>
        <span class="n">J2</span> <span class="p">=</span> <span class="n">I</span><span class="p">;</span>                 <span class="c">% J2 is defined for compatibility reasons</span>
        <span class="n">H1</span> <span class="p">=</span> <span class="nb">eye</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">J2</span><span class="p">);</span>         <span class="c">% H1 is defined for compatibility reasons</span>
        <span class="n">epsilon</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">z</span><span class="p">,[],</span><span class="n">J</span><span class="p">)</span><span class="o">*</span> <span class="n">H</span><span class="o">*</span><span class="n">inv</span><span class="p">(</span><span class="n">H</span><span class="o">&#39;*</span><span class="n">H</span><span class="p">),</span><span class="s">&#39;fro&#39;</span><span class="p">)</span> <span class="p">;</span> <span class="c">% typicaly z is not known, but epsilon can be estimated with sigma. </span>
        <span class="n">nu_H</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">tight_H</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span> 
    <span class="k">else</span>
        <span class="c">% if the measurement are correlated, we need to take accound of H.</span>
        <span class="c">% This will slow down drastically the computation since H is not a</span>
        <span class="c">% tight frame</span>
        <span class="n">H1</span> <span class="p">=</span> <span class="n">H</span><span class="p">;</span>                 <span class="c">% H1 is defined for compatibility reasons</span>
        <span class="n">J2</span> <span class="p">=</span> <span class="n">J</span><span class="p">;</span>                 <span class="c">% J2 is defined for compatibility reasons</span>
        <span class="n">epsilon</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">z</span><span class="p">(:));</span>   <span class="c">% typicaly z is not known, but epsilon can be estimated with sigma. </span>
        <span class="n">tight_H</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">nu_H</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H1</span><span class="p">)</span>^<span class="mi">2</span><span class="p">;</span>
    <span class="k">end</span>   
    
    <span class="c">% Other parameters for the L2 projection</span>
    <span class="n">paramL2</span><span class="p">.</span><span class="n">tight</span> <span class="p">=</span> <span class="n">tight_phi</span> <span class="o">*</span> <span class="n">tight_H</span><span class="p">;</span>
    <span class="n">paramL2</span><span class="p">.</span><span class="n">nu</span> <span class="p">=</span> <span class="n">nu_phi</span> <span class="o">*</span> <span class="n">nu_H</span><span class="p">;</span>
    <span class="n">paramL2</span><span class="p">.</span><span class="n">tol</span> <span class="p">=</span> <span class="mf">1e-5</span><span class="p">;</span>
    <span class="n">paramL2</span><span class="p">.</span><span class="n">maxit</span> <span class="p">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">paramL2</span><span class="p">.</span><span class="n">verbose</span> <span class="p">=</span> <span class="n">verbose</span> <span class="o">-</span><span class="mi">1</span><span class="p">;;</span>
    <span class="n">paramL2</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>              <span class="c">% measures</span>
    <span class="n">paramL2</span><span class="p">.</span><span class="n">epsilon</span> <span class="p">=</span> <span class="n">epsilon</span><span class="p">;</span>  <span class="c">%radius of the ball</span>
    <span class="n">paramL2</span><span class="p">.</span><span class="n">A</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">)</span> <span class="n">Phi1</span><span class="p">(</span> <span class="nb">reshape</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">H1</span><span class="o">&#39;</span><span class="p">,[],</span><span class="mi">1</span> <span class="p">));</span>      <span class="c">% operator</span>
    <span class="n">paramL2</span><span class="p">.</span><span class="n">At</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">)</span> <span class="nb">reshape</span><span class="p">(</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">Phit1</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">N</span><span class="p">,</span><span class="n">J2</span><span class="p">)</span><span class="o">*</span><span class="n">H1</span> <span class="p">,[],</span><span class="mi">1</span> <span class="p">);</span>   <span class="c">% adjoint operator</span>
  
    
    <span class="n">f1</span><span class="p">.</span><span class="n">prox</span><span class="p">=@(</span><span class="n">x</span><span class="p">,</span><span class="n">T</span><span class="p">)</span> <span class="n">fast_proj_b2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">T</span><span class="p">,</span> <span class="n">paramL2</span><span class="p">);</span>
    <span class="n">f1</span><span class="p">.</span><span class="n">eval</span><span class="p">=@(</span><span class="n">x</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>            
    
    
    
    <span class="c">%****  Proj simplex  **************************************************</span>
    <span class="c">% The home-made simplex_proj function will achieve two projections in</span>
    <span class="c">% order to satify to constraints</span>
    <span class="c">%</span>
    <span class="c">%     -   (S)_{i,j} &gt; 0  for all i,j    (positivity constraint)</span>
    <span class="c">%</span>
    <span class="c">%     -   Sum_j   S_{i,j}  = 1 for all i</span>
    <span class="c">%</span>
    
    <span class="n">param_simplex</span><span class="p">.</span><span class="n">algo</span> <span class="p">=</span> <span class="s">&#39;duchi&#39;</span><span class="p">;</span>
    
    <span class="n">f2</span><span class="p">.</span><span class="n">prox</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">,</span><span class="n">T</span><span class="p">)</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">simplex_proj</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">I</span><span class="p">),</span><span class="n">param_simplex</span><span class="p">),</span><span class="n">N</span><span class="o">*</span><span class="n">I</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">f2</span><span class="p">.</span><span class="n">eval</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>   
    
    
    
    <span class="c">%****  Prox_TV  *******************************************************</span>
    <span class="c">% </span>
    <span class="c">% Minimization of the TV norm</span>
    <span class="c">%</span>
    <span class="c">%   argmin_S  Sum_j ||S_{.,j}||_TV</span>
    <span class="c">%</span>
    
    <span class="n">param_TV</span><span class="p">.</span><span class="n">maxit</span> <span class="p">=</span> <span class="mi">200</span><span class="p">;</span>
    <span class="n">param_TV</span><span class="p">.</span><span class="n">tol</span> <span class="p">=</span> <span class="mf">10e-5</span><span class="p">;</span>
    <span class="n">param_TV</span><span class="p">.</span><span class="n">verbose</span> <span class="p">=</span> <span class="n">verbose</span> <span class="o">-</span><span class="mi">1</span><span class="p">;;</span>
    <span class="n">param_TV</span><span class="p">.</span><span class="n">useGPU</span><span class="p">=</span><span class="n">GLOBAL_useGPU</span><span class="p">;</span>
        
    <span class="n">k</span><span class="p">=</span><span class="mf">0.3333</span><span class="p">;</span>
    
    <span class="n">f3</span><span class="p">.</span><span class="n">prox</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">,</span><span class="n">T</span><span class="p">)</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">prox_tv</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n1</span><span class="p">,[]),</span><span class="n">k</span><span class="o">*</span><span class="n">T</span><span class="p">,</span><span class="n">param_TV</span><span class="p">),</span><span class="n">N</span><span class="o">*</span><span class="n">I</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>    
    <span class="n">f3</span><span class="p">.</span><span class="n">eval</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">)</span> <span class="n">norm_tv</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n1</span><span class="p">,[]));</span>   <span class="c">% This norm is considered</span>
                                                <span class="c">% as the objective function</span>
                                                
    
<span class="c">%     f3.prox = @(x,T) reshape(prox_TV(reshape(x,n1,[]), T, &#39;beta&#39;,0.249,...</span>
<span class="c">%         &#39;min_rel_obj&#39;, 10e-5, &#39;it_max&#39;, 200, ...</span>
<span class="c">%         &#39;it_min&#39;, 2, &#39;verbose&#39;, 0),N*I,1); </span>
    
                                          
    <span class="c">%****** Corresponding sparsifying 2D Wavelet Operator *****************</span>
    <span class="c">%   </span>
    <span class="c">%   You can replace the TV minimization constraint by a Wavelet-L1 constraint   </span>
    <span class="c">%</span>
    <span class="c">%   In that case we minimize</span>
    <span class="c">%</span>
    <span class="c">%   argmin_S  Sum_j || W2D&#39; * S_{.,j} ||_1</span>
    <span class="c">%</span>
    <span class="c">%   Need for sparco toolbox !</span>
    
    <span class="c">% Selection of the wavelet</span>
    <span class="n">wname</span> <span class="p">=</span> <span class="s">&#39;Daubechies&#39;</span><span class="p">;</span> <span class="c">% &#39;haar&#39;, &#39;Daubechies&#39;</span>
    
    <span class="n">DecLev</span> <span class="p">=</span> <span class="nb">log2</span><span class="p">(</span><span class="n">n1</span><span class="p">);</span>
   
    <span class="n">W2D</span> <span class="p">=</span> <span class="n">opWavelet</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="n">wname</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="n">DecLev</span><span class="p">,</span><span class="s">&#39;min&#39;</span><span class="p">);</span> <span class="c">% Creation of the wavele</span>

    <span class="n">opW2D_blk</span> <span class="p">=</span> <span class="n">opBlock_diag_same</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">W2D</span><span class="p">);</span>

    <span class="n">paramW</span><span class="p">.</span><span class="n">verbose</span><span class="p">=</span> <span class="n">verbose</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">paramW</span><span class="p">.</span><span class="n">maxit</span><span class="p">=</span><span class="mi">100</span><span class="p">;</span>
    <span class="n">paramW</span><span class="p">.</span><span class="n">At</span><span class="p">=@(</span><span class="n">x</span><span class="p">)</span> <span class="n">opW2D_blk</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">paramW</span><span class="p">.</span><span class="n">A</span><span class="p">=@(</span><span class="n">x</span><span class="p">)</span> <span class="n">opW2D_blk</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">k</span><span class="p">=</span><span class="mf">0.033333</span><span class="p">;</span>
    <span class="n">f4</span><span class="p">.</span><span class="n">prox</span><span class="p">=@(</span><span class="n">x</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">prox_l1</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,[],</span><span class="mi">1</span><span class="p">),</span><span class="n">k</span><span class="o">*</span><span class="n">T</span><span class="p">,</span><span class="n">paramW</span><span class="p">),</span><span class="n">N</span><span class="o">*</span><span class="n">I</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>  
    <span class="n">f4</span><span class="p">.</span><span class="n">eval</span><span class="p">=@(</span><span class="n">x</span><span class="p">)</span> <span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">(:),</span><span class="mi">1</span><span class="p">);</span>   




<span class="c">%% solve the problem using the toolbox function   </span>
     
    <span class="c">%Initial point</span>
    <span class="n">x_0</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">I</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    
    <span class="c">%Create the vector of functions</span>

        <span class="n">F</span> <span class="p">=</span> <span class="p">{</span><span class="n">f1</span> <span class="n">f2</span> <span class="n">f3</span><span class="p">};</span>     <span class="c">% Use the TV norm</span>
        <span class="n">param</span><span class="p">.</span><span class="nb">gamma</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">param</span><span class="p">.</span><span class="n">tol</span> <span class="p">=</span> <span class="mf">3e-5</span><span class="p">;</span>
        

    <span class="c">% Parameter for ppxa algorithm</span>
    <span class="n">param</span><span class="p">.</span><span class="n">maxit</span> <span class="p">=</span> <span class="mi">200</span><span class="p">;</span>
    <span class="n">param</span><span class="p">.</span><span class="n">lambda</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">param</span><span class="p">.</span><span class="n">verbose</span> <span class="p">=</span> <span class="n">verbose</span><span class="p">;</span>
    <span class="c">% TV</span>
    <span class="n">t</span><span class="p">=</span><span class="n">cputime</span><span class="p">;</span>
    <span class="c">% solve the probleme</span>
    <span class="p">[</span><span class="n">S_est_tv</span><span class="p">]=</span> <span class="n">ppxa</span><span class="p">(</span><span class="n">x_0</span><span class="p">,</span><span class="n">F</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
    <span class="n">estimation_time_tv</span><span class="p">=</span><span class="n">cputime</span><span class="o">-</span><span class="n">t</span>
    
    <span class="c">%Create the vector of functions</span>
    <span class="n">F</span> <span class="p">=</span> <span class="p">{</span><span class="n">f1</span> <span class="n">f2</span> <span class="n">f4</span><span class="p">};</span>    
        <span class="n">param</span><span class="p">.</span><span class="nb">gamma</span> <span class="p">=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">paramW</span><span class="p">.</span><span class="n">A</span><span class="p">(</span><span class="n">sources</span><span class="p">(:))));</span>
        <span class="n">param</span><span class="p">.</span><span class="n">tol</span> <span class="p">=</span> <span class="mf">1e-6</span><span class="p">;</span>
    <span class="n">t</span><span class="p">=</span><span class="n">cputime</span><span class="p">;</span>
    <span class="c">% solve the probleme</span>
    <span class="p">[</span><span class="n">S_est_l1</span><span class="p">]=</span> <span class="n">ppxa</span><span class="p">(</span><span class="n">x_0</span><span class="p">,</span><span class="n">F</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
    <span class="n">estimation_time_l1</span><span class="p">=</span><span class="n">cputime</span><span class="o">-</span><span class="n">t</span>
    
    <span class="c">%reshape the solution</span>
    <span class="n">S_est_tv</span> <span class="p">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">S_est_tv</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">I</span><span class="p">);</span>
    <span class="n">S_est_l1</span> <span class="p">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">S_est_l1</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">I</span><span class="p">);</span>
    
    <span class="c">% image estimation with S</span>
    <span class="n">Img_est_tv</span> <span class="p">=</span> <span class="n">S_est_tv</span><span class="o">*</span><span class="n">H</span><span class="o">&#39;</span><span class="p">;</span>
    <span class="n">Img_est_l1</span> <span class="p">=</span> <span class="n">S_est_l1</span><span class="o">*</span><span class="n">H</span><span class="o">&#39;</span><span class="p">;</span>
    


<span class="c">%% Display the result</span>


    <span class="c">% Evalutaion of the error</span>
    <span class="n">Reconstruction_MSE_tv</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Img</span><span class="p">(:)</span><span class="o">-</span><span class="n">Img_est_tv</span><span class="p">(:))</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">Img</span><span class="p">(:))</span>
    <span class="n">Sources_MSE_tv</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">sources</span><span class="p">(:)</span><span class="o">-</span><span class="n">S_est_tv</span><span class="p">(:))</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">S_est_tv</span><span class="p">(:))</span>
    <span class="n">Reconstruction_MSE_l1</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Img</span><span class="p">(:)</span><span class="o">-</span><span class="n">Img_est_l1</span><span class="p">(:))</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">Img</span><span class="p">(:))</span>
    <span class="n">Sources_MSE_l1</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">sources</span><span class="p">(:)</span><span class="o">-</span><span class="n">S_est_l1</span><span class="p">(:))</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">S_est_l1</span><span class="p">(:))</span>

   	<span class="n">figure</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">S_est</span><span class="p">=</span><span class="n">S_est_tv</span><span class="p">;</span>
        <span class="n">method</span><span class="p">=</span><span class="s">&#39;TV&#39;</span><span class="p">;</span>
        <span class="c">% plot the result in a nice shape</span>
        <span class="n">S_est</span><span class="p">=</span><span class="n">S_est</span><span class="p">(:);</span>
        <span class="n">S_est1</span><span class="p">=</span><span class="n">S_est</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">*</span><span class="n">I</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">S_est2</span><span class="p">=</span><span class="n">S_est</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">N</span><span class="o">*</span><span class="n">I</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">);</span>
        <span class="n">S_est1</span><span class="p">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">S_est1</span><span class="p">,</span><span class="n">n1</span><span class="p">,[]);</span>
        <span class="n">S_est2</span><span class="p">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">S_est2</span><span class="p">,</span><span class="n">n1</span><span class="p">,[]);</span>
        <span class="n">imagesc</span><span class="p">([</span><span class="n">S_est1</span><span class="p">;</span><span class="n">S_est2</span><span class="p">]);</span>
        <span class="n">set</span><span class="p">(</span><span class="n">gca</span><span class="p">,</span><span class="s">&#39;xtick&#39;</span><span class="p">,[])</span>
        <span class="n">colormap</span> <span class="n">hot</span><span class="p">;</span>
        <span class="c">% Plot separtation lines</span>
        <span class="n">hold</span> <span class="n">on</span><span class="p">;</span>
        <span class="n">N_lines</span><span class="p">=</span><span class="n">I</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N_lines</span><span class="p">;</span>
           <span class="n">plot</span><span class="p">(</span><span class="n">ii</span><span class="o">*</span><span class="n">n2</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="s">&#39;k&#39;</span><span class="p">,</span><span class="s">&#39;Linewidth&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="k">end</span>

        <span class="n">plot</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="n">n1</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">n2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;k&#39;</span><span class="p">,</span><span class="s">&#39;Linewidth&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">title</span><span class="p">(</span><span class="n">sprintf</span><span class="p">(</span><span class="n">strcat</span><span class="p">(</span><span class="s">&#39; Recovered sources by:&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="n">method</span><span class="p">,</span><span class="s">&#39; minimization \n Reconstruction MSE (dB): %g \n Sources MSE (dB): %g \n CPU-Time: %g &#39;</span><span class="p">),</span><span class="mi">20</span><span class="o">*</span><span class="nb">log10</span><span class="p">(</span><span class="n">Reconstruction_MSE_tv</span><span class="p">),</span><span class="mi">20</span><span class="o">*</span><span class="nb">log10</span><span class="p">(</span><span class="n">Sources_MSE_tv</span><span class="p">),</span><span class="n">estimation_time_tv</span><span class="p">));</span>
   	
    
    <span class="n">figure</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">S_est</span><span class="p">=</span><span class="n">S_est_l1</span><span class="p">;</span>
        <span class="n">method</span><span class="p">=</span><span class="s">&#39;Wavelet-L1&#39;</span><span class="p">;</span>
        <span class="c">% plot the result in a nice shape</span>
        <span class="n">S_est</span><span class="p">=</span><span class="n">S_est</span><span class="p">(:);</span>
        <span class="n">S_est1</span><span class="p">=</span><span class="n">S_est</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">*</span><span class="n">I</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">S_est2</span><span class="p">=</span><span class="n">S_est</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">N</span><span class="o">*</span><span class="n">I</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">);</span>
        <span class="n">S_est1</span><span class="p">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">S_est1</span><span class="p">,</span><span class="n">n1</span><span class="p">,[]);</span>
        <span class="n">S_est2</span><span class="p">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">S_est2</span><span class="p">,</span><span class="n">n1</span><span class="p">,[]);</span>
        <span class="n">imagesc</span><span class="p">([</span><span class="n">S_est1</span><span class="p">;</span><span class="n">S_est2</span><span class="p">]);</span>
        <span class="n">set</span><span class="p">(</span><span class="n">gca</span><span class="p">,</span><span class="s">&#39;xtick&#39;</span><span class="p">,[])</span>
        <span class="n">colormap</span> <span class="n">hot</span><span class="p">;</span>
        <span class="c">% Plot separtation lines</span>
        <span class="n">hold</span> <span class="n">on</span><span class="p">;</span>
        <span class="n">N_lines</span><span class="p">=</span><span class="n">I</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">N_lines</span><span class="p">;</span>
           <span class="n">plot</span><span class="p">(</span><span class="n">ii</span><span class="o">*</span><span class="n">n2</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="s">&#39;k&#39;</span><span class="p">,</span><span class="s">&#39;Linewidth&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="k">end</span>

        <span class="n">plot</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="n">n1</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">n2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;k&#39;</span><span class="p">,</span><span class="s">&#39;Linewidth&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">title</span><span class="p">(</span><span class="n">sprintf</span><span class="p">(</span><span class="n">strcat</span><span class="p">(</span><span class="s">&#39; Recovered sources by:&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="n">method</span><span class="p">,</span><span class="s">&#39; minimization \n Reconstruction MSE (dB): %g \n Sources MSE (dB): %g \n CPU-Time: %g &#39;</span><span class="p">),</span><span class="mi">20</span><span class="o">*</span><span class="nb">log10</span><span class="p">(</span><span class="n">Reconstruction_MSE_l1</span><span class="p">),</span><span class="mi">20</span><span class="o">*</span><span class="nb">log10</span><span class="p">(</span><span class="n">Sources_MSE_l1</span><span class="p">),</span><span class="n">estimation_time_l1</span><span class="p">));</span>
</pre></div>


            </div>
        </div>

        <div class="include" file="../include/footer.html"></div>
    </div>
</div>
<!-- These two have to be here to dynamically load the included parts -->
<script src="../include/jquery.min.js"></script>
<script src="../include/bootstrap-select.min.js"></script>
<script src="../include/rrp.js" type="text/javascript"></script>
</body>
</html>




